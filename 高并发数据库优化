### 反范式设计

反范式设计就是逻辑上同一个字段我们缓存（冗余）在多个表里面，为什么要做这种表的冗余呢？

因为，我们很多时候我们去做查询（关联查询）这个对性能的影响还是比较大的，如果单纯的查询可能还好。

但是，如果是更新，比如有两张表A和B，这两张表有一个外键，它们把它关系起来的，这个时候可能要先去B表，然后再通过查询出来的这个值去更新A表，这样你会发现整个事务会拉大。

```sql
A表中有id_a,B表中有id_b id_a
// 通过B表id_b更新A表的col
SELECT id_a FROM B WHERE id_b = XXX
UPDATE A SET col=YYY WHERE id_a=......
```

比如说你B的查出来的这个数据量比较大，那你本地的内存压力也会比较大。如果你把这个WHERE条件的字段直接冗余到A表里，你就可以单表去进行更新了。这样就能够避免前面说的问题，而且能提升整个表更新的一个并发量。

```sql
A表:中有id_a id_b,B表:id_b id_a
// 通过B表id_b更新A表的col
UPDATE A SET col=YYY WHERE id_b=...
```

当然，这里也会有另个一个副作用，你这个WHERE条件本身的字段你要去更新的话，那你就需要更新两张表，如果更新这个字段是非常高频的操作，那其实本身也会拉大这个事务。所以，需要结合你的场景去分析它到底是属于哪一种情况去做这种反范式的设计。

###  不要设置外键

很多人发现很多公司的系统层面的确没有设置外键，但是很多人却没有深研这里面的具体原因。我们经常在讲操作的一些一致性、完整性这些东西，其实外键就是其中的一个约束。你要去做一个更新，如果涉及到外键的话需要额外的去做一些操作，而且这个操作之间可能去加锁，那这样对更新操作其实是有些性能影响的，所以外键这个东西我们一般不会直接设置在数据库上，更多是在业务层面去做一个约束。

因为，很多公司的数据库隔离级别并没有采用默认的**“可重复读（Repeatable Read）”**，而是采用了**“读已提交（Read Committed）”**，相信大多数人都知道不同的隔离级别，很大程度都是通过一些锁机制去实现的，常见的对象级别的锁包括：

- Predicates
- Tuples
- Transaction IDs
- Relations
- Relation Extention
- Non-Relations
- Pages
- Advisoory

对于行级别的锁采用的是Relations锁实现的。所以省掉这些锁的开销能一定程度的提升你的一个并发度，这就是性能跟完整性一些权衡取舍，也需要根据你的实际业务场景来。

### 字段扩展

对于字段扩展性来说，这里举一个很简单的例子，比如说：你在业务上要填写一个表单，但是这个表单的样式或者字段它是动态变化的。那这个数据库表的字段设计应该怎么去做呢？

这里有两种方案来解决这个问题呢？第一种方案就是将所的表单类型给它枚举出来，把每一个要填的项目都给它建成一个独立的字段，但是这样会发现一个问题：表会越来越大。而且，后面新增加了表的样式之后，字段也会不断的去调整。数据库表的字段应该是一个很稳定的概念，如果你频繁的根据业务去进行一些调整（动态调整），那这个运维的成本其实是非常高的。

当然，可能很多人会想到用一些NoSQL的数据库，比如采用MongoDB这种文档型的数据库去做这种事情。因为，它不需要事先去定义它的结构。其实就在关系数据库层面我们也可以建立一个通用的字段(form_content)，这个字段就存一个字符串（JSON字符串），你这个表单的全部内容就存在一个JSON给它传进去，去保存整个表单里面填的所有Key/Value。

当你去展示表格的时候，后端不需要关心这个表里面具体有哪些Key/Value，直接把这个字符串丢给前端去解析就好了。后端的话对于这个表单内容的处理就会非常的简单。

当然，看上去不错的方案实际上在一些场景下来会有一些缺陷的。比如说：你要通过这个表里面的一些K/V做一些索引（查询），但是你在表里面存的就是一个字符串，那怎么去做索引呢？你当然可以用LIKE一些语句去实现。但是，这样性能就非常低了，你没有办法用到Mysql底层的一些B+树的索引。所以，Mysql的高版本也支持JSON的这种数据结构好像也支持索引。但是，我们实际在生产环境当中还是会去考虑这个点，如果真的里面的这段需要索引的话，我们会将它拆出来。

### 冷热分离

在表层面可以做一个**冷热分离**，这里不是指那种分表的冷热分离。这里举一个简单的例子，比如说商品表有些字段是高频的要CURD操作，但是有些字段它基本不怎么变化，而且这些不变化的字段存的数据量还比较大，如果你把这些所有的字段都放在一个商品表里面的话，那这样后面的数据CURD操作其实性能也会非常低的。

所以，关于商品的存储模型我们会建立两张表：商品主表(item)和商品扩展表(item_detail)。将这些频繁CURD的操作放在主表里面去，然后把用的比较少的一些字段放在商品扩展表里面去。这样做的好处是主表的CURD和索引的构建的性能都能提升很多。

### 事务控制

对于数据库的集群我们去做拆分的时候会习惯性的去考虑同一块业务把它放在一起，这确实也是符合微服务的一些思想的。但是，我们还是要去考虑技术上的一些挑战。比如后期业务上同一些操作可能涉及到事务问题应该尽量把它们放在同一个数据库里面。

这里，我们还是以电商的业务场景来举例说明。比如：数据库做分片的时候，你不知道通过哪一个维度去分片，但是你知道有一些操作是在用户维度，有一些操作是在店铺的维度，那同一个店铺的一些操作那我们就去给它做一个分片。

其实，分布式事务最好的解决方案就是在做微服务拆分的时候数据库层面先考虑好，怎么去尽量的避免分布式事务。

### 单表操作

尽量单表去操作数据，这一点可能很多人背八股文的时候知道有这么一个约束，但是具体什么原因不太清楚。这里需要说明的是并不是所有的业务尽量去单表操作就一定好，这还是要看你的业务场景来决定。

比如，有一些传统的业务系统它大量的业务都是采用存储过程去实现的，一个SQL动不动就几千行，人家的系统也运行的好好的，也没有什么大的问题，所以要相信一句话：存在即合理。所以，必须结合实际的场景去分析和解决问题。

那什么场景比较适合用这种单表的操作呢？互联网公司一般都是采用这种增量式迭代的开发，一个很大的原因就是你未来的需求是不确定的。所以，抛开这种连表查询的性能问题，可能更多的就是为了后期分库分表更加的方便，再加上应用服务器这一块它的弹性也是比较大的，如果内存上有压力的话，我们可以去横向的扩容也算是一种以空间换时间的思想。

但是，这个性能没有绝对的优劣，因为你单表去JOIN虽然在数据库层面开销要大一些，但是应用节点跟数据库之间的IO其实只有一次，所以说具体哪一种性能好一点主要还不好说。主要还是写SQL很复杂之后你后期去做分库分表做拆分的时候会非常的麻烦。

所以，同样你要去做这一块的前瞻性设计，你要考虑你这个是用自增ID还是用分布式ID。如果你这个表的ID要去做外键而且后期大概率要去做分库分表，那你尽量前期就要去做分布式ID的生成。
