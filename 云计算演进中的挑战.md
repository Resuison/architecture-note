### 1、背景

由于现在大多数公司都已经把服务器放在云端了，所以现在基于云原生和容器化的一些技术衍生出来了一些概念非常的多。

其实，云计算最早出来的概念就是按照你的使用去付费，但是现在我们的实际情况很多还是去租用它一个机器配置，比如：CPU的核心数、内存和磁盘的容量。

虽然，在云厂商内部它已经做了一层的虚拟化，但在使用方看来它还是跟物理机器没有太多的区别，整个运维的成本其实并没有降低，还是要关心这些东西。而且租用的这个配置大部也是按照时间去计费的，并不能真正的按理想的情况：就是按照流量去计费。

serverless很多人把它翻译成无服务，其实我个人觉得这个翻译并不是很准确。less它不一定是没有的意思也有可能是少量的意思。serverless它并不是说没有服务这个概念，而是说你不用太关心服务本身、不用去关心容器、不用关心后面部署运维的东西。你只需要关心你需要多大的流量、多大的一个RT、多大的一个并发量，按照你的流量去付费就行了。

所以，serverless这个概念强调的是你的服务能力的一个抽象，它跟我们一般说的云服务IaaS、PaaS、SaaS这些概念是不在一个层级的。

很多人其实经常容易把一些抽象的概念和具体的一些实现把它混淆，就像服务网格service mesh它的一个具体实现可能像istio这种产品，那同样的serverless它具体的表现形式现在主要有两大类：

- FaaS：Function as a Service它就是一个最小函数作为一个服务，比如：AWS lambda；
- BaaS：Backend as a Service它就是一些基础服务，比如：数据库的一些访问、Google的FireBase、权限认证的一些基础服务等。

所以，平时在了解概念的时候多关注它是在哪个层次进行抽象的，不要把一些相似的进行混淆。第一，就是抽象的层次。第二，就是要把垂直关注的点把它区分出来，比如：serverless和service mesh。

- serverless：关注更多的是从服务器和应用机器这一层，最开始从虚拟化到docker容器，最后再到kubernetes serverless这一条线去衍生出来的，它关注的点一直是计算资源这一块，它要解决的问题更多是应用集群本身的一个资源抽象和云服务化的一个过程。
- service mesh：服务风格整个服务治理过程当中遇到的一些问题的一个云原生的抽象。

整个演进过程其实也可以应用到架构设计思想里面，比如水平拆分和垂直拆分这是我们会用到的架构设计思想。

提出serverless这个概念之后，那作为我们业务开发人员更多就关注我们业务开发不太会关注整个运维部署这一块的东西了，这样做了之后很多中小型公司其实就没有太多运维的负担了，不用再被一些持续集成、devOps的一些基础设备所困扰，而且这样更细粒的去部署跟控制之后也便于后面去按照真正的流量需求去计费。  

### 2、云原生的挑战

虽然，Serverless不用去关心它的扩容和缩容，但是对于RT比较敏感的一些场景，平滑性比较高的场景，突然来一个峰值的时候，它这个流量扛不住可能要去做这个扩容肯定是会有一些影响的，很难做到一个真正的平滑的过渡。其次，serverless的这种服务更多的是比较单一的原子化服务，它不太适合这种多服务网状的调用，比如说A服务调用B服务，B服务调用C服务。另外，对于大多数系统持续的都是这种高流量的也不太适合用serverless，这些更多的是出于这种使用成本上的考虑，就像你买车和租车一样，如果你天天都要开车，你还不如去买一辆车，反而租车就不划算了一样的道理。

另外一个挑战就是serverless它肯定也是一个高度虚拟化的一个容器在后面部署，所以说它也会遇到一些多租户的问题。可能它这种粒度这种多租房的风险，资源的争抢会更加的严重。现在采用的是一些物理机部署多个docker镜像，偶尔也会出现这种资源争抢的情况，就是同一台物理机上部署不同的服务，它们之间会相互的影响。

另外之前也尝试过用这种FaaS的方式去部署，发现有一些共享资源的情况也会遇到一些瓶颈。比如说你这个函数里面涉及到数据库连接的一个初始化，那这种FaaS的部署弹性缩扩容这个对连接沲资源的消耗是非常巨大的。所以，这种可能还要在中间去部署一个DB的一个连接沲的代理。

总而言之，serverless就不太适合这种有状态的服务，比如说一些长连接WebSocket，那这种情况去单独维护一个会话集群。网上还有很多文章说serverless会更加的安全，其实这个也不一定，比如说你本身服务它依赖linux底层的一些库，那这个时候你还是要去关心本身它的内部它使用的linux的版本。所以现在提供serverless这些云服务厂商，它们更多是这种责任共享的机制，而不是所有的安全责任都是由它去保证。

serverless它就是对整个计算机docker镜像进行了一个虚拟化更上层的一个高度抽象化的一个服务能力，不管是各种框架还是一些最新的一些概念，你会发现整个计算机后端的一个演进过程其实都是在做一件事情就是不断的抽象，让用户操作变得更加的简单。当然，这里的用户不是我们狭义上的这种系统的用户，而是说对于框架这一层我们开发者就是用户。那对于框架这一层可能我们部署的容器它也是一个用户。

以前的程序员很多都是全栈的，因为前后端到运维部署都是自己搞掂。提是随着的产品的不断迭代，逐渐分离出来了前端、后端。后端也分出来了大数据、算法、DBA各种细分的领域。这样分工协作才有可能去做一个更加复杂的产品，这个是必然的趋势。

早期的时候发布系统的时候要写各种脚本和敲各种Linux的命令，但现在我们去发布更多的就是这种就是一个网页上的页面，然后在页面上去选择一个Git的分支，打包一个镜像就可以直接去滚动发布了。这客观上来说确实是提升了整个团队的一个开发效率，让业务开发能够走得更快关注在自己解决业务问题上面，让做DevOps的持续集成的工程师专注在平台建设这一块。但久而久之下来我也会发现我对于Linux的一些命令就不太熟悉了。发展到后期就会发现要么你是一个技术专家，要么你就是一个螺丝钉。



